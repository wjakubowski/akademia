30.04.18

kod do zadan z wczoraj:






#include <assert.h>
#include <map>
#include <iostream>

using namespace std;

int powNToK(int n, int k)
{
    assert(k >= 0);
    if (k == 0) return 1;
    else return n * powNToK(n, k-1);
}

long fib(int n)
{
    assert(n >= 0);
    if (n <= 1) return n;
    else return fib(n-1) + fib(n-2);
}

long fibCached(int n)
{
    assert(n >= 0);
    if (n <= 1) return n;
    else {
        static map<int,long> fibs;
        auto it = fibs.find(n);
        long fibN;
        if (it == fibs.end()) {
            fibN = fibCached(n - 1) + fibCached(n - 2);
            fibs[n] = fibN;
        }
        else {
           fibN = it->second;
        }
        return fibN;
    }
}

int main()
{
    cout << "Running misc functions..." << endl;

    for (int i = 0; i < 45; ++i) {
       cout << "fib(" << i << ") = " << fib(i) << endl;
    }

    cout << endl;

    for (int i = 0; i < 8; ++i) {
       cout << "pow2ToK(" << i << ") = " << powNToK(2, i) << endl;
    }

    cout << endl;

    for (int i = 0; i < 50; ++i) {
       cout << "fibCached(" << i << ") = " << fibCached(i) << endl;
    }
}



#############################################################################################

Do zaimplementowania:

plik .h

do edytowania - punkt startowy
trzeba to uogolniac - dwukierunkowo, szablon dla wartosci, mozna robic TDD, mozna trzymac liczbe elementow

#include <string>

class List {
    struct Node {
        int value;
        Node *pNext;
    };

    Node *pHead;
public:
    List();
    List(int const arr[], int size);
    ~List();
    void insert(int value);
    void reverse();//moga byc 2 wersje: statyczna przyjmuje liste i zwraca odwrucona, druga odwraca sama siebie
    string toString();
    bool contains(int element);
    // ...
};


##############################################################################################


//w konstruktorze domyslnym wskaznik na NULL, moga byc glembokosci poddrzew
//najlepiej pisac rekursyjnie nie iteracyjnie

class BinSearchTree {
    struct BSTNode
    {
        int value;
        BSTNode *pLeft;
        BSTNode *pRight;
    };

    BSTNode *pRoot;
public:
    BinSearchTree();
    BinSearchTree(int const arr[], int size);
    ~BinSearchTree();
    void insert(int value);
    List toList();
    void toString();
    bool contains();
    void mirror();//odbicie wagami wzglendem pionowej osi 
    // ...
};








///

zakladki:




https://github.com/gibsjose/cpp-cheat-sheet/blob/master/Data%20Structures%20and%20Algorithms.md
https://en.wikipedia.org/wiki/Bucket_sort
https://pl.wikipedia.org/wiki/Sortowanie_przez_zliczanie
https://pl.wikipedia.org/wiki/Kategoria:Algorytmy_grafowe
https://pl.wikipedia.org/wiki/SOLID_(programowanie_obiektowe)
https://web.archive.org/web/20150905081103/http://www.objectmentor.com/resources/articles/dip.pdf
https://pl.wikipedia.org/wiki/Unified_Modeling_Language
https://pl.wikipedia.org/wiki/Diagram_klas
https://stackoverflow.com/questions/12854778/abstract-class-vs-interface-in-c






















